;
(function() {
var pkg = {};
pkg["github.com/matthewmueller/golly/testdata/27-global-fetch/promise"] = (function() {
Promise.prototype.Catch = function() {
var p = this;
return p;
};
function Promise (o) {
o = o || {};
this.value = o.value || null;
this.err = o.err || null;
};
Promise.prototype.Then = function() {
var p = this;
return p;
};
return {
  Promise: Promise
};
})();
pkg["github.com/matthewmueller/golly/js"] = (function() {
function Raw (src) {
return null;
};
return {
  Raw: Raw
};
})();
pkg["github.com/matthewmueller/golly/runtime"] = (function() {
var js = pkg["github.com/matthewmueller/golly/js"];
function Chan (o) {
o = o || {};
this.capacity = o.capacity || 0;
this.values = o.values || [];
this.sends = o.sends || [];
this.recvs = o.recvs || [];
this.closed = o.closed || false;
};
function Channel (capacity) {
return new Chan({
  capacity: capacity
});
};
function Deferred () {

if (!(this instanceof Deferred)) return new Deferred()
var self = this

var p = new Promise(function(resolve, reject) {
	self.resolve = resolve
	self.reject = reject
})

self.then = p.then.bind(p)
self.catch = p.catch.bind(p)
;
return self;
};
Chan.prototype.Recv = function() {
var c = this;
if (c.values.length > 0) {
var value = c.values[0]

c.values = c.values.slice(1)
return Promise.resolve(value)
};
if (c.sends.length > 0) {
var send = c.sends[0]

c.sends = c.sends.slice(1)
if (c.closed) {
send.promise.reject(new Error('send on closed channel'))
return Promise.resolve()
}
send.promise.resolve()
return Promise.resolve(send.value)
};
if (c.closed) {
return Promise.resolve()
};
var promise = Deferred();
c.recvs = c.recvs.concat(promise);
return promise;
};
Chan.prototype.Send = function(value) {
var c = this;
if (c.closed) {
return Promise.reject(new Error('send on a closed channel'))
};
if (c.recvs.length > 0) {
var recv = c.recvs[0]

c.recvs = c.recvs.slice(1)
recv.resolve(value)
return Promise.resolve()
};
if (c.values.length < c.capacity) {
c.values = c.values.concat(value)
return Promise.resolve()
};
var promise = Deferred();
c.sends = c.sends.concat(new send({
  value: value,
  promise: promise
}));
return promise;
};
function send (o) {
o = o || {};
this.value = o.value || null;
this.promise = o.promise || null;
};
return {
  Chan: Chan,
  Channel: Channel,
  Deferred: Deferred
};
})();
pkg["github.com/matthewmueller/golly/testdata/27-global-fetch"] = (function() {
var runtime = pkg["github.com/matthewmueller/golly/runtime"], promise = pkg["github.com/matthewmueller/golly/testdata/27-global-fetch/promise"];
function Fetch (url, options) {
return new promise.Promise({});
};
function Github (o) {
o = o || {};
this.login = o.login || "";
this.name = o.name || "";
this.bio = o.bio || "";
};
Response.prototype.JSON = function() {
var r = this;
return r.responseText;
};
function Response (o) {
o = o || {};
this.responseText = o.responseText || "";
};
async function main () {
var p = Fetch("https://api.github.com/users/matthewmueller", null);
var ch = new runtime.Channel();
p.Then(await async function(v) {
var res = v;
return res.JSON();
}).Then(await async function(v) {
await ch.Send(v);
return null;
}).Catch(await async function(e) {
console.log(e);
return null;
});
var gh = await ch.Recv();
console.log(gh.login, "-", gh.name);
};
return {
  fetch: fetch,
  Github: Github,
  Response: Response,
  main: main
};
})();
return pkg["github.com/matthewmueller/golly/testdata/27-global-fetch"].main();
})()